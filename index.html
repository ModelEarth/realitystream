<!DOCTYPE html>
<html lang="en-us">
<head>
<meta charset="utf-8">
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>RealityStream - Machine Learning Classification Models</title>
<link rel="shortcut icon" href="data:image/x-icon;," type="image/x-icon">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link type="text/css" rel="stylesheet" href="/localsite/css/base.css" id="/localsite/css/base.css">
<link type="text/css" rel="stylesheet" href="/cloud/run/css/param.css">
<script type="text/javascript" src="/localsite/js/localsite.js?showheader=true"></script>


<!-- Load required scripts before the loadMarkdown calls -->
<script src="https://cdn.jsdelivr.net/npm/js-yaml@4/dist/js-yaml.min.js"></script>

<script src="https://d3js.org/d3.v5.min.js"></script>

<!-- Tabulator (grid) -->
<link rel="stylesheet" href="https://unpkg.com/tabulator-tables@5.5.2/dist/css/tabulator.min.css">
<script src="https://unpkg.com/tabulator-tables@5.5.2/dist/js/tabulator.min.js"></script>

<!-- Earthscape helper (loads CSV and renders Tabulator) -->
<script src="/localsite/js/earthscape.js"></script>

<script>
(function normalizeIncomingFromTimeline() {
  const h = (window.location.hash || '').replace(/^#/, '');
  if (!h) return;

  const p = new URLSearchParams(h);

  // If timeline sends features.dcid/targets.dcid, move to rs_dcid so param-input.js won't override YAML.
  const incoming =
    p.get('rs_dcid') ||
    p.get('features.dcid') ||
    p.get('targets.dcid');

  if (incoming && !p.get('rs_dcid')) {
    p.set('rs_dcid', incoming);
  }

  // IMPORTANT: remove these so param-input.js cannot overwrite YAML based on them
  p.delete('features.dcid');
  p.delete('targets.dcid');

  const newHash = p.toString();
  const newUrl = window.location.pathname + window.location.search + (newHash ? '#' + newHash : '');
  window.history.replaceState(null, '', newUrl);
})();
</script>

<script>
let externalSite = "https://model.earth"; // Since cloud repo is not always a submodule.
if (location.host.indexOf('localhost') >= 0) {
  externalSite = "..";
}
loadScript(externalSite + '/cloud/run/js/param-input.js', function() {
  loadBaseParamsSelect();

  // refresh AFTER param-input has had time to write YAML into #paramText pre
  setTimeout(() => {
    if (window.rsRefreshFromYaml) window.rsRefreshFromYaml();
  }, 300);
});

</script>


<style>
#paramText {
  font-size: 0.9em;
  overflow: scroll !important;
  padding-top: 0px;
  padding-bottom: 0px;
}
button {
  background-color: #375a7f;
  border: none;
  color: white;
  padding: 10px 16px;
  font-size: 14px;
  margin: 4px 2px;
  cursor: pointer;
  border-radius: 4px;
  white-space: nowrap;
}

</style>


<script>

loadMarkdown("README.md", "readmeDiv", "_parent");
loadMarkdown("about.md", "aboutDiv", "_parent");
loadMarkdown("input/blinks/README.md", "blinksDiv", "_parent");
loadMarkdown("input/industries/README.md", "industriesDiv", "_parent");
loadMarkdown("projects.md", "proj", "_parent");
</script>
</head>

<body data-param-input="realitystream">

<div class="content contentpadding" style="position:relative;">

  <!-- Preview Modal for Tabulator -->
<div id="rsPreviewBackdrop" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.35); z-index:10000;"></div>

<div id="rsPreviewModal" style="display:none; position:fixed; top:70px; left:50%; transform:translateX(-50%);
  width:min(1100px, calc(100vw - 40px)); max-height: calc(100vh - 120px);
  background:#fff; border:1px solid #ddd; border-radius:12px; padding:12px; z-index:10001;
  box-shadow:0 18px 40px rgba(0,0,0,0.25); overflow:auto;">

  <div style="display:flex; justify-content:space-between; align-items:center; gap:12px; margin-bottom:10px;">
    <div style="font-weight:700;">Preview data</div>
    <button id="rsPreviewClose" type="button"
      style="border:none; background:#6b7280; border-radius:10px; padding:6px 10px; cursor:pointer;">✕</button>
  </div>

  <div id="rsPreviewMeta" style="font-size:12px; color:#555; margin-bottom:10px;"></div>

  <!-- Tabulator renders inside this div -->
  <div id="rsPreviewTable"></div>
</div>


<div style="float:right;margin-top:6px">
  <a href="https://github.com/modelearth/realitystream/"><img src="../localsite/img/icon/github/github.png" style="width:42px"></a>
</div>

<a href="/projects">Active Projects</a>
<h1>RealityStream</h1>

Scroll to the bottom for a list of RealityStream <a href="#projects">projects</a>.<br>
View <a href="../reports/">Report Output</a> (Under Development) - View <a href="../reports/2025/eye-blinks-rbf-2025-10-30/">Eye Blink Detection sample report</a><br><br>

<select id="parambase"></select><br>

<div id="pathControls"></div>

<div id="paramText" class="codetext" contenteditable>
<pre>
folder: naics6-bees-counties

features:
  data: industries
  common: Fips
  path: https://raw.githubusercontent.com/ModelEarth/community-timelines/main/training/naics6/US/counties/2020/US-ME-training-naics6-counties-2020.csv

targets:
  data: bees
  path: https://raw.githubusercontent.com/ModelEarth/bee-data/main/targets/bees-targets-top-20-percent.csv

models: xgboost
</pre>
</div>
Edit your yaml above and paste into our <a href="input/industries/">Run Models CoLab</a>.<br><br>


  <div id="aboutDiv"></div>
  <div id="pathDiv"></div><br>

  <div class="pagecard">
  <div class="cardstyle">
    <div id="blinksDiv"></div>
  </div>
  </div>

  <div class="pagecard">
  <div class="cardstyle">
    <div id="industriesDiv"></div>
  </div>
  </div>

<hr>

<div id="readmeDiv"></div>


<b><a href="input/industries">Run Models CoLab documentation</a></b><br>

<!--
<b><a href="streamlit">Streamlit App documentation</a></b> -   
<a href="https://reality.streamlit.app/">reality.streamlit.app</a> | 
<a href="https://share.streamlit.io/">My streamlit apps</a> | 
<a href="https://echarts.streamlit.app/">echarts.streamlit.app</a><br>
-->

<span style="display:none" class="local"><br><a href="https://docs.google.com/document/d/1aR3VjrQj94X542uzJ-qXwRgIH8SzcLzE0z_jfT8bYbU/">Hosting notes Google Doc</a></span>

<!--
  https://laughing-orbit-6475wr7w55j2rrjq.github.dev/
-->
<br><br>

<div id="proj"></div>

</div>





<script>
(function() {
  const state = {
    features: [],  
    target: null  
  };
let isSyncingYaml = false;
let yamlRefreshTimer = null;
let hasConsumedIncoming = false;
let hasSeenBaseYaml = false;

window.rsHasTarget = function () {
  return !!(state.target && state.target.dcid);
};


  function uid() {
    return 'id_' + Math.random().toString(16).slice(2);
  }

  function getHashParams() {
  const h = (window.location.hash || '').replace(/^#/, '');
  return new URLSearchParams(h);
}

function setHashParams(p) {
  const newHash = p.toString();
  history.replaceState(null, '', window.location.pathname + window.location.search + (newHash ? '#' + newHash : ''));
}

function readCsvParam(p, key) {
  const v = (p.get(key) || '').trim();
  if (!v) return [];
  return v.split(',').map(s => s.trim()).filter(Boolean);
}

function writeCsvParam(p, key, list) {
  const unique = Array.from(new Set(list.map(s => s.trim()).filter(Boolean)));
  if (!unique.length) p.delete(key);
  else p.set(key, unique.join(','));
}


function syncHashFromState() {
  const p = getHashParams();
  const dcidFeatures = state.features
  .filter(x => x.kind === 'dcid')
  .map(x => x.dcid);

writeCsvParam(p, 'rs_features', dcidFeatures);

if (state.target?.kind === 'dcid' && state.target?.dcid) {
  p.set('rs_target', state.target.dcid);
} else {
  p.delete('rs_target');
}


  const newHash = p.toString();
  history.replaceState(null, '', window.location.pathname + (newHash ? '#' + newHash : ''));
}

function updateJoinStatus() {
  const el = document.getElementById('rsJoinStatus');
  if (!el) return;

  const yaml = rsGetYamlObjSafe();
  const features = (yaml && yaml.features) ? yaml.features : {};
  const common = (features.common || '').toString().trim();
  const scope = (features.scope || yaml.scope || '').toString().trim();

  if (!common && !scope) {
    el.style.display = 'none';
    return;
  }

  const scopeLabel = scope || 'country';
  const commonLabel = common || 'FIPS';
  el.textContent = `Joining on: ${scopeLabel} using common ${commonLabel}`;
  el.style.display = 'block';
}

function isProbablyDcid(v) {
  if (!v || typeof v !== 'string') return false;
  if (v.startsWith('http')) return false;

 
  if (v.includes('/')) return true;

  return /^[A-Za-z][A-Za-z0-9_]+$/.test(v);
}


function rsGetYamlObjSafe() {
  try {
    const preTag = document.querySelector('#paramText pre');
    if (!preTag || !window.jsyaml) return null;
    return jsyaml.load(preTag.textContent) || null;
  } catch (e) {
    return null;
  }
}

function rsGetPathInfoForRole(role) {
  const y = rsGetYamlObjSafe();
  if (!y) return { fullPath: '', hasPH: false, placeholderPath: '', previewPath: '', pv: null };

  const section = (role === 'target') ? (y.targets || {}) : (y.features || {});
  const fullPath = (section.path || '').toString().trim();
  if (!fullPath) return { fullPath: '', hasPH: false, placeholderPath: '', previewPath: '', pv: null };

  const hasPH = pathHasPlaceholders(fullPath);
  const pv = hasPH ? getPreviewValuesFromYaml(y) : null;   // uses your existing function
  const previewPath = hasPH ? applyPlaceholders(fullPath, pv) : '';

  return {
    fullPath,
    hasPH,
    placeholderPath: hasPH ? fullPath : '',
    previewPath,
    pv
  };
}


  function createRowCard(item, role) {
    if (window.rsCreateRowCard) {
      const roleLabel = role === 'features' ? 'Features' : 'Targets';
      const card = window.rsCreateRowCard({
        item,
        role,
        roleLabel,
        getPathInfo: rsGetPathInfoForRole,
        isProbablyDcid,
        onAdd: () => {
          if (window.rsOpenAddPopupWithRole) {
            window.rsOpenAddPopupWithRole(role);
          }
        },
        onRemove: () => {
          removeItem(item.id);
        },
        onPreviewInline: (url, tableId) => {
          rsOpenPreviewInline(url, tableId);
        }
      });
      return card;
    }

    const fallback = document.createElement('div');
    fallback.className = 'rsRowCard';
    fallback.textContent = item.label || item.dcid;
    return fallback;
  }


  function render(shouldSyncYaml = true) {
    const fList = document.getElementById('rsFeaturesList');
    const tList = document.getElementById('rsTargetList');
    const fEmpty = document.getElementById('rsFeaturesEmpty');
    const tEmpty = document.getElementById('rsTargetEmpty');

    if (!fList || !tList || !fEmpty || !tEmpty) {
      return;
    }

    fList.innerHTML = '';
    tList.innerHTML = '';

    state.features.forEach(item => {
      const card = createRowCard(item, 'features');
      fList.appendChild(card);
      if (card && card._rsAttachMenu) {
        card._rsAttachMenu();
        delete card._rsAttachMenu;
      }
    });
    if (state.target) {
      const card = createRowCard(state.target, 'target');
      tList.appendChild(card);
      if (card && card._rsAttachMenu) {
        card._rsAttachMenu();
        delete card._rsAttachMenu;
      }
    }

    fEmpty.style.display = state.features.length ? 'none' : 'block';
    tEmpty.style.display = state.target ? 'none' : 'block';

    updateJoinStatus();

    if (shouldSyncYaml) syncYamlFromState();
  }


  function removeItem(id) {
    state.features = state.features.filter(x => x.id !== id);
    if (state.target && state.target.id === id) state.target = null;
    syncHashFromState();
    render();
  }

 function moveItem(id, from, to) {
  if (from === to) return;

  let item = null;

  // Remove from source
  if (from === 'features') {
    const idx = state.features.findIndex(x => x.id === id);
    if (idx >= 0) {
      item = state.features[idx];
      state.features.splice(idx, 1);
    }
  } else if (from === 'target') {
    if (state.target && state.target.id === id) {
      item = state.target;
      state.target = null;
    }
  }

  if (!item) return;

  // Drop into destination
  if (to === 'target') {
    // don’t allow replacing an existing target
    if (state.target) {
      alert('Only 1 target is allowed. Remove the current target first.');

      // put the item back where it came from
      if (from === 'features') state.features.push(item);
      else state.target = item;

      // keep hash consistent too
      syncHashFromState();
      render(false);  
      return;
    }
    state.target = item;
  } else {
    state.features.push(item);
  }

  
  syncHashFromState();

  render(); // will sync YAML
}


  function setupDropZone(zoneId, role) {
    const zone = document.getElementById(zoneId);
    if (!zone) return;
    zone.addEventListener('dragover', (e) => {
      e.preventDefault();
      zone.style.borderColor = '#4CAF50';
    });
    zone.addEventListener('dragleave', () => {
      zone.style.borderColor = '#ddd';
    });
    zone.addEventListener('drop', (e) => {
      e.preventDefault();
      zone.style.borderColor = '#ddd';
      try {
        const data = JSON.parse(e.dataTransfer.getData('text/plain'));
        moveItem(data.id, data.from, role);
      } catch (err) {
        console.warn('Bad drag data', err);
      }
    });
  }

 
  // This updates features.dcid / targets.dcid in YAML based on UI.
  function syncYamlFromState() {
    
    const paramTextDiv = document.getElementById('paramText');
    const preTag = paramTextDiv ? paramTextDiv.querySelector('pre') : null;
    
    if (!preTag || !window.jsyaml) return;

    isSyncingYaml = true;

    let yamlObj;
    try {
      yamlObj = jsyaml.load(preTag.textContent) || {};
    } catch (e) {
      return; // if YAML is mid-edit and invalid, don't break anything
    }

    // Ensure objects exist
    yamlObj.features = yamlObj.features || {};
    yamlObj.targets = yamlObj.targets || {};

 
const featureDcids = state.features.filter(x => x.kind === 'dcid').map(x => x.dcid);
const featureDatas = state.features.filter(x => x.kind === 'data').map(x => x.dcid);

 
const parseCsv = (val) => {
  if (!val) return [];
  if (Array.isArray(val)) return val.map(x => String(x).trim()).filter(Boolean);
  return String(val).split(',').map(s => s.trim()).filter(Boolean);
};

if (featureDcids.length) {

  const existing = parseCsv(yamlObj.features.dcid);
  const combined = [...new Set([...existing, ...featureDcids])];
  yamlObj.features.dcid = combined.join(', ');
  delete yamlObj.features.data;

} else if (featureDatas.length) {
  const existing = parseCsv(yamlObj.features.data);
  const combined = [...new Set([...existing, ...featureDatas])];
  yamlObj.features.data = combined.join(', ');
  delete yamlObj.features.dcid;

} else {
  delete yamlObj.features.dcid;
  delete yamlObj.features.data;
}




  if (!state.target) {
  delete yamlObj.targets.dcid;
  delete yamlObj.targets.data;
} else if (state.target.kind === 'dcid') {
  yamlObj.targets.dcid = state.target.dcid;
  delete yamlObj.targets.data;
} else if (state.target.kind === 'data') {
  yamlObj.targets.data = state.target.dcid;
  delete yamlObj.targets.dcid;
}


    const newYaml = jsyaml.dump(yamlObj, { lineWidth: -1, noCompatMode: true });
    preTag.textContent = newYaml;
    setTimeout(() => { isSyncingYaml = false; }, 0);

  }


  function looksLikeBaseYamlLoaded(preText) {
  if (!preText) return false;
  
  return preText.includes('folder:') || preText.includes('features:') || preText.includes('targets:') || preText.includes('models:');
}


function splitCsvOrArray(v) {
  if (!v) return [];
  if (Array.isArray(v)) return v.map(x => String(x).trim()).filter(Boolean);
  if (typeof v === 'string') {
    return v.split(',').map(s => s.trim()).filter(Boolean);
  }
  return [String(v).trim()].filter(Boolean);
}

function filenameFromPath(path) {
  if (!path || typeof path !== 'string') return '';
  const clean = path.split('?')[0].split('#')[0];
  const parts = clean.split('/');
  return (parts[parts.length - 1] || '').trim();
}


function pathHasPlaceholders(path) {
  return typeof path === 'string' && /\{[a-zA-Z0-9_]+\}/.test(path);
}

function getPreviewValuesFromYaml(yamlObj) {
  // Pick defaults  
  const year = yamlObj?.endyear || yamlObj?.startyear || 2021;

  // If YAML says state: all
  let state = (yamlObj?.state || '').toString().trim();

if (!state || state.toLowerCase() === 'all') {
  state = 'NY';
} else {
  // If CSV list like "ME,VT,NH,MA" pick first for preview URL
  const first = state.split(',').map(s => s.trim()).filter(Boolean)[0];
  if (first) state = first;
}

  const naics = yamlObj?.naics || 2;

  return { year, state, naics };
}

function applyPlaceholders(path, values) {
  if (!path || typeof path !== 'string') return path;
  return path
    .replaceAll('{year}', String(values.year))
    .replaceAll('{state}', String(values.state))
    .replaceAll('{naics}', String(values.naics));
}


// For Features, the UI picks features.dcid if it exists otherwise features.data otherwise the filename from features.path
// For Target, it picks targets.dcid if it exists otherwise targets.data otherwise the filename from targets.path
function pickYamlIdsAndLabeler(sectionObj) {
  sectionObj = sectionObj || {};

  const dcids = splitCsvOrArray(sectionObj.dcid);
  if (dcids.length) {
    return dcids.map(v => ({
      value: v,
      label: v,
      kind: 'dcid',
      href: `https://datacommons.org/browser/${encodeURIComponent(v)}`
    }));
  }

  const datas = splitCsvOrArray(sectionObj.data);
  if (datas.length) {
    return datas.map(v => ({
      value: v,
      label: v,
      kind: 'data',
      href: ''  
    }));
  }

  const paths = splitCsvOrArray(sectionObj.path);
  if (paths.length) {
    return paths.map(p => {
      const file = filenameFromPath(p) || p;
      return {
        value: file,      
        label: file,     
        kind: 'path',
        href: p           
      };
    });
  }

  return [];
}





 
  
  function refreshFromYaml() {
     

  const paramTextDiv = document.getElementById('paramText');
  const preTag = paramTextDiv ? paramTextDiv.querySelector('pre') : null;
  if (!preTag || !window.jsyaml) return;

  if (isSyncingYaml) return;

  // If the hash already has rs_features, do NOT rebuild features from YAML.
  const p = getHashParams();
  const hashFeatures = readCsvParam(p, 'rs_features');
  const hashTarget = (p.get('rs_target') || '').trim();

  try {
    const yamlObj = jsyaml.load(preTag.textContent) || {};
 
if (!hashFeatures.length) {
  const picked = pickYamlIdsAndLabeler(yamlObj.features);
  const featurePath = (yamlObj.features && yamlObj.features.path) ? yamlObj.features.path : '';
const values = getPreviewValuesFromYaml(yamlObj.features || {});
const valuesT = getPreviewValuesFromYaml(yamlObj.features || {});

const hasPH = pathHasPlaceholders(featurePath);
const previewPath = hasPH ? applyPlaceholders(featurePath, values) : featurePath;

state.features = picked.map(x => ({
  id: uid(),
  dcid: x.value,
  label: x.label,
  kind: x.kind,
  href: x.href,

  // NEW:
  fullPath: featurePath,                  
  hasPlaceholders: hasPH,
  placeholderPath: hasPH ? featurePath : '',
  previewPath: hasPH ? previewPath : '',
  previewWith: hasPH ? values : null
}));

} else {
  const featurePath = (yamlObj.features && yamlObj.features.path) ? yamlObj.features.path : '';
const hasPH = pathHasPlaceholders(featurePath);
const pv = hasPH ? getPreviewValuesFromYaml(yamlObj) : null;
const previewPath = hasPH ? applyPlaceholders(featurePath, pv) : '';

state.features = hashFeatures.map(v => {
  const isDcid = isProbablyDcid(v);
  return {
    id: uid(),
    dcid: v,
    label: v,
    kind: isDcid ? 'dcid' : 'data',
    href: isDcid ? `https://datacommons.org/browser/${encodeURIComponent(v)}` : '',

    fullPath: featurePath,
    hasPlaceholders: hasPH,
    placeholderPath: hasPH ? featurePath : '',
    previewPath: hasPH ? previewPath : '',
    previewWith: hasPH ? pv : null
  };
});

}


// Target: prefer hashTarget if present, else YAML
if (hashTarget) {
  state.target = { id: uid(), dcid: hashTarget, label: hashTarget, kind: 'dcid', href: `https://datacommons.org/browser/${encodeURIComponent(hashTarget)}` };
} else {
  const pickedT = pickYamlIdsAndLabeler(yamlObj.targets);
  const x = pickedT[0];
  const targetPath = (yamlObj.targets && yamlObj.targets.path) ? yamlObj.targets.path : '';
const valuesT = getPreviewValuesFromYaml(yamlObj);
const hasPHT = pathHasPlaceholders(targetPath);
const previewPathT = hasPHT ? applyPlaceholders(targetPath, valuesT) : targetPath;

state.target = x ? {
  id: uid(),
  dcid: x.value,
  label: x.label,
  kind: x.kind,
  href: x.href,

  // NEW:
  fullPath: targetPath,
  hasPlaceholders: hasPHT,
  placeholderPath: hasPHT ? targetPath : '',
  previewPath: hasPHT ? previewPathT : '',
  previewWith: hasPHT ? valuesT : null
} : null;

}






    render(false);  
     
  } catch (e) {
    // ignore invalid YAML while user types
  }
}

window.rsRefreshFromYaml = refreshFromYaml;


  document.addEventListener('DOMContentLoaded', () => {
  const initDropZones = () => {
    // Features drop targets
    setupDropZone('rsFeaturesList', 'features');
    setupDropZone('rsFeaturesEmpty', 'features');

    // Target drop targets
    setupDropZone('rsTargetList', 'target');
    setupDropZone('rsTargetEmpty', 'target');
  };

  if (typeof waitForElm === 'function') {
    waitForElm('#rsFeaturesList').then(() => {
      initDropZones();
      render(false);
    });
  } else {
    initDropZones();
    render(false);
  }

const p0 = getHashParams();
const savedFeatures = readCsvParam(p0, 'rs_features'); // comma separated
const savedTarget = (p0.get('rs_target') || '').trim();

if (savedFeatures.length) {
  state.features = savedFeatures.map(v => {
    const isDcid = isProbablyDcid(v);
    return {
      id: uid(),
      dcid: v,
      label: v,
      kind: isDcid ? 'dcid' : 'data',
      href: isDcid ? `https://datacommons.org/browser/${encodeURIComponent(v)}` : ''
    };
  });
}

if (savedTarget) {
  const isDcid = isProbablyDcid(savedTarget);
  state.target = {
    id: uid(),
    dcid: savedTarget,
    label: savedTarget,
    kind: isDcid ? 'dcid' : 'data',
    href: isDcid ? `https://datacommons.org/browser/${encodeURIComponent(savedTarget)}` : ''
  };
}


  refreshFromYaml();  // initial read
  render(false);           // initial render

  setTimeout(() => {
  const didConsume = consumeIncomingDcidFromHash();
  if (didConsume) hasConsumedIncoming = true;
}, 300);


  // Watch YAML box for changes (param-input.js updates it after load)
  const paramTextDiv = document.getElementById('paramText');
  const preTag = paramTextDiv ? paramTextDiv.querySelector('pre') : null;
// Snapshot the initial YAML that was in the HTML (before param-input.js rewrites it)
const initialPreText = preTag ? preTag.textContent : '';

  if (preTag) {
  const observer = new MutationObserver(() => {
    if (yamlRefreshTimer) clearTimeout(yamlRefreshTimer);

    yamlRefreshTimer = setTimeout(() => {
      // 1) Always rebuild UI from YAML
      refreshFromYaml();

      // 2) Try consuming incoming timeline selection once
      if (!hasConsumedIncoming) {
        const didConsume = consumeIncomingDcidFromHash();
        if (didConsume) hasConsumedIncoming = true;
      }
    }, 100);
  });

  observer.observe(preTag, { childList: true, subtree: true, characterData: true });
}


   
  document.addEventListener('hashChangeEvent', () => {
    if (yamlRefreshTimer) clearTimeout(yamlRefreshTimer);
    yamlRefreshTimer = setTimeout(() => {
      refreshFromYaml();
    }, 50);
  });


  // When user changes Base parameters dropdown, param-input.js will update YAML + hash.
// Force refresh after that happens.
const parambaseEl = document.getElementById('parambase');
if (parambaseEl) {
  parambaseEl.addEventListener('change', () => {
    if (yamlRefreshTimer) clearTimeout(yamlRefreshTimer);
    yamlRefreshTimer = setTimeout(() => refreshFromYaml(), 150);
  });
}

// Also react to real hash changes (fallback in case custom event isn't fired)
window.addEventListener('hashchange', () => {
  if (yamlRefreshTimer) clearTimeout(yamlRefreshTimer);
  yamlRefreshTimer = setTimeout(() => refreshFromYaml(), 150);
});


window.rsAddSelection = function(role, dcid, label, forcedKind) {
  const kind = forcedKind || (isProbablyDcid(dcid) ? 'dcid' : 'data');

  const item = {
    id: uid(),
    dcid,
    label: label || dcid,
    kind,
    href: (kind === 'dcid')
      ? `https://datacommons.org/browser/${encodeURIComponent(dcid)}`
      : ''
  };


  if (role === 'target') {
   
    if (state.target) {
      alert('Only 1 target is allowed. Remove the current target first.');
      return;
    }
    state.target = item;

  } else {
    // prevent duplicates
    const exists = state.features.some(x => x.dcid === dcid);
    if (!exists) state.features.push(item);
  }

  syncHashFromState();
  render();
};

function consumeIncomingDcidFromHash() {
  const p = getHashParams();

  const incomingRaw = (p.get('rs_dcid') || '').trim();
  if (!incomingRaw) return false;

  // support comma-separated incoming dcids
  const incomingList = incomingRaw
    .split(',')
    .map(s => s.trim())
    .filter(Boolean);

  if (!incomingList.length) return false;

  let role = (p.get('rs_role') || 'features').trim();
  if (role === 'targets') role = 'target';

  if (role === 'target') {
   if (state.target && state.target.dcid) {
    alert('Only 1 target is allowed. Remove the current target first.');

    // ✅ very important: don’t keep re-triggering
    p.delete('rs_dcid');
    setHashParams(p);
    return true;
  }

  const dcid = incomingList[0];
  p.set('rs_target', dcid);
  window.rsAddSelection('target', dcid, dcid, 'dcid');

  } else {
    // append ALL incoming to rs_features
    const current = readCsvParam(p, 'rs_features');
    incomingList.forEach(dcid => {
      if (!current.includes(dcid)) current.push(dcid);
      window.rsAddSelection('features', dcid, dcid, 'dcid');

    });
    writeCsvParam(p, 'rs_features', current);
  }

  // remove single-use incoming param
  p.delete('rs_dcid');
  setHashParams(p);

  return true;
}








});

})();


  function rsOpenPreviewInline(csvUrl, elementId) {
    // Show modal
    // earthscape.js expects: my.dataset and my.elementID
    const my = {
      dataset: csvUrl,
      elementID: elementId
    };

    // This will d3.csv(...) then new Tabulator("#rsPreviewTable", ...)
    loadEarthScape(my);
  }

  function rsOpenPreviewModal(csvUrl) {
    document.getElementById('rsPreviewBackdrop').style.display = 'block';
    document.getElementById('rsPreviewModal').style.display = 'block';
    document.getElementById('rsPreviewMeta').innerHTML =
      `Source: <a href="${csvUrl}" target="_blank" rel="noopener noreferrer">${csvUrl}</a>`;
    const tableEl = document.getElementById('rsPreviewTable');
    tableEl.innerHTML = "";
    const my = {
      dataset: csvUrl,
      elementID: "rsPreviewTable"
    };
    loadEarthScape(my);
  }

  function rsClosePreviewModal() {
    document.getElementById('rsPreviewBackdrop').style.display = 'none';
    document.getElementById('rsPreviewModal').style.display = 'none';
    document.getElementById('rsPreviewTable').innerHTML = "";
  }

  document.addEventListener("DOMContentLoaded", () => {
    document.getElementById("rsPreviewClose")?.addEventListener("click", rsClosePreviewModal);
    document.getElementById("rsPreviewBackdrop")?.addEventListener("click", rsClosePreviewModal);

    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape") rsClosePreviewModal();
    });
  });


</script>

</body>
</html>
